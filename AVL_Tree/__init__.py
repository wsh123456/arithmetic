# avl树，是一种平衡二叉树(每个节点的左右子树相差小于等于1)

#           a
#         /   \
#        b     c
#      /  \
#    d     e
# 如上就是一棵平衡二叉树
# 传统的二分搜索树最坏的情况会退化成链表
# avl树进行自平衡，保持自身既是二分搜索树又满足平衡二叉树

# 实现方法就是在添加新的元素后进行平衡因子检验，大于一的话进行左旋或者优选操作保持平衡
# 具体左旋还是右旋根据左右子树的深度
# 以左旋为例：
#            a
#          /   \
#         t1    b
#              /  \
#             t2   c
#                 /  \
#                t3   t4

# 此时树的大小关系为：t1 < a < t2 < b < t3 < c < t4
# 平衡因子  a : -2 ,  b : -1  ,  c : 0
# 可见a点为不平衡的点，进行左旋操作
#  1. 找到 a 的右子树 ，看平衡因子 大于零还是小于零(判断左子树元素多了还是右子树)
#  2. 将 b 的左子树t2先移除，a 的右子树置空
#  3. 将 a 及其左子树添加到b的左子树(即原t2的位置)
#  4. 将 t2 添加到a 的右子树，返回b节点
# 完成左旋操作后的新树:
#             b
#          /    \
#        a        c
#      /   \     /  \
#    t1    t2   t3  t4

# 对于LR 或者RL 的情况，以LR为例：
#            y                                   y                                  z
#          /   \                               /   \                              /   \
#        x     T4       x 向左旋转           z       T4    y 向右旋转           x      y
#         \             ---------->        /  \            ---------->           \    /  \
#          z                             x    T2                                 T1  T2   T4
#         / \                             \
#       T1  T2                             T1